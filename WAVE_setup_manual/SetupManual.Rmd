---
title: "Masters Thesis"
author: "Nick Zinck"
date: "May 2017"
output: 
  pdf_document:
    toc: true
    toc_depth: 3
    number_sections: true
bibliography: "F:/Nick Zinck/Shiny Water Quality/Thesis/Thesis.bib"

nocite: | 
  @noauthor_shiny_nodate, @noauthor_shiny_nodate-1
---

```{r loadpack, include=FALSE}
# Load Packages
library(rmarkdown)
library(knitr)
library(tidyverse)
library(shiny)
library(kableExtra)
require(DiagrammeR)
require(DiagrammeRsvg)
require(rsvg)
```

```{r enter data,include=FALSE}
pdf_digraph <- function(filename, code, width = 500, height = NULL){
  capture.output({
  g <- grViz(paste("digraph{", code, "}"))
  DiagrammeRsvg::export_svg(g) %>% charToRaw %>% rsvg::rsvg_pdf(filename, width = width, height = height)
  },  file='NUL')
  knitr::include_graphics(filename)
}
```

# Introduction

## Objective

A comprehensive watershed monitoring program includes collecting much water quality, meteorological, and hydrological data. Although data collection is always important, much of this data is underutilized due to a timely processes of searching, displaying, and analyzing data. Spreadsheet applications are likely not an effective way to store large datasets and visualization and analysis tools are limited. Relational database applications serve as a better home for these large datasets, yet visualization and analysis tools are commonly even more limited. A logical solution is to store large datasets within a relational database and pair this database with an outside application specialized for data visualization, analysis, and automation.

This project specifically is working to facilitate the DCR's (Department of Conservation and Recreation's) data entry, searching, visualization, and analysis process through an R-based application creation tool called Shiny. R is an open source programming language used largely for data statistics and visualization. Shiny is an open source application that allows one to create applications which have a friendly user interface component as well as a server component which uses R to do all the work. A Shiny application can be fully customized by the designer for unique tasks. Features of the DCR Shiny application include easy data searching, water quality time series plotting and analysis, water quality regression analysis, geospatial data visualization and analysis, and more. Through the insight that this application brings, future data collection needs can be better assessed which will direct changes to the current watershed monitoring program.

Automation is a useful, yet underutilized tool that can save an organization much time day to day on decreasing the number of repeated tasks that come along with searching, displaying, and analyzing water quality data.
The Application is shared openly through Github and can be ran locally on any computer with two lines of code. Hosting the application online at a URL is also a possibility. 


The objective of this project is to create an application that facilitates the data entry, searching, visualization, and analysis of water quality data and other related watershed data. 

## Quabbin and Wachusett Reservoir System

The Wachusett Reservoir is located in central Massachusetts and is the main supply of the Boston metropolitan area. The reservoir has a capacity of about 65 billion gallons with a length of 8.4 miles. The reservoir is part of the Massachusetts Water Resource Authority's (MWRA) water supply system which is managed in partnership with the Department of Conservation and Recreation (DCR).

## Data Collection


There are various types of data collected in the watershed. Due to the vast amount of data from various sources the raw data can be in very different formats. Storing data in a central database in similar format is crucial to set up a platform for efficient data analysis. The application provides a connection to this data in the database with an easy-to-use user interface for a human user to interact with the data.

Water quality data includes tributary data grab samples and well as.

Reservoir data includes grab samples, ____, and profile data.

Water quality data related to forestry practices is also collected to compare water quality parameters between managed and unmanaged forests. 

This Application will give insight to data collection needs

Data external to the DCR can is also incorporated into the application including hydrological data and meteorological data. Precipitation data is collected from the . River Flow data is collected by the USGS, some gauges in collaboration with the DCR and some independently. Weather data is collected by ____ . 


# Background

## Water Quality Sampling Plan

The water quality sampling plan consists of routine sampling at various sites. These sites are Core Sites and EQA sites. 

### Site Locations

### Collection Frequency

## Other Watershed Visualization Application Programs

### Propritary

### Open-Source

## Previous Watershed Studies for Quabbin and Wachsuett Reservoir

## Something Else (look at what I wrote down from Tobiason)


# Application Overview

## DWSPA

The Drinking Water Supply Protection Analysis Application (DWSPA) allows the visualization and analysis of the water quality data and watershed data. There main features of the App include data query and export, data visualization, and data analysis.

### Data query and export

### Visulaization and Analysis
#### Temporal Trends

Temporal plots are created based on the data that is queried. These plots are interactive and have many customization options including grouping and adding trendlines. Temporal Statistics can be computed with ease which include the maximum, minimum, average, etc statistics and can be grouped by years, months, seasons, parameters, and sites.

#### Spatial Trend Analysis

Spatial trend analysis is incorporated in many locations in the app but primarily lives on the map plot tab. Geospatial plots allows the user to easily compare a parameter statistic across all sites in a visual of plots on their choice of map. Spatial analysis also exists in any tab when multiple sites are chosen for analysis.

#### Correlation Trend Analysis

Correlation trend analysis in this application consists of correlation between many types of parameters including water quality, hydrological, and meteorological parameters. Correlation plots can be easily created to see the correlation between parameters with regression lines. correlation statistics can also be computed and shown in an easy to read table. Both of these methods compare parameters taken from the same day and site to minimize temporal and spatial discrepancies.

Two y-axis plots also allows to compare temporal trends between parameters. This is similar to correlation analysis although, shows less of the direct relationship but allows to keep more of the temporal information.


## DWSPI

### Data import

The Drinking Water Supply Protection Import Application (DWSPI) facilitates importing raw data from multiple sources into the database. Each Data Type has a formatting function script that is written in R to format the data. As more data sources are added or data sources are changed, these can be uploaded into the database. The user is prompted to select dataset type and the user will be shown a list of raw data files in the appropriate dataset type location on their computer. The user then selects a file from their computer and then press a button to format the data. A Warning message will be sent to the user if their was a problem with the data or if the data already exists in the database. After a successful formatting, the user will be able to see the formatted data in a table on the screen and an import button will appear that the user can press to import the data if they are satisfied with how the data looks.  Once the data is imported, the raw data file is moved from the unprocessed folder on their computer to the processed folder.


# DWSPA Setup Manual

## R and RStudio download
## Database Connections
## Setup File

# DWSPI Setup Manual

## R and RStudio download
## Database Connections
## Setup File


# DWSPA User Manual

The Drinking Water Supply Protection Analysis Application (DWSPA) should be set up on ones computer per the DWSPA Setup Manual prior to attempting to start the App.

## OVerview

This application purpose is to facilitate the searching, visualization, and analysis of water quality data. The Application allows for easy visualization and analysis of water quality temporal trends, parameter correlation, geospatial trends, and other data visualization and analysis. The application can also be used to just view data in an easier more simpler format than in the Access databases with maps to help identify the site locations. The application can be used as a means to filter and export data for outside use. This application is flexible in that features can be added and modified as new needs become apparent.

## How it works

The DWSPA App is created with RStudio's Shiny free software. Shiny is a package in R that enables an App creator to use the R programming language to create an application that consists of a front-end HTML and JavaScript user interface in which the user interacts with the data. Shiny video and written tutorials [@____] are a great resource on how Shiny works. The Application fetches data that is in the Access Databases stored on the internal network. Upon starting the App, the App will fetch the latest data that is in the databases. The App Code is stored on Github which is an open source code sharing site. The latest Shiny Application code on Github is ran every time the App is opened. The Code that is on Github should be the most up-to-date working code that the App builders have sent to Github.

Shiny's components that the user can see consists of two categories: Input objects and Output Objects. Input objects essentially allow the user to communicate with the App and the  output objects are the App communicate with the User. input objects will be refered to as Input Widgets in this user manual and can take the form of checkboxs, selection drop-down lists, and Date Range Calendar inputs. The full list of Shiny Widgets can be seen in the Shiny Widget Gallery (@) . Output objects include plots, tables, maps, images, and tables. Shiny takes the input of from the user and executes code which are essentially directions for a sequence of computations and other operations to create the outputs that the user sees.

The Shiny Widget Gallery shows all of the available widgets in Shiny in an operational form. The 


## Startup

To open the DWSPA App, the user must double click on the DWSPA icon. A message will appear to notify the user that the App is opening and may take up to 30 seconds. The user may press okay to exit or the user may just leave the message alone, neither will not effect the speed at which the App opens. When the App is ready, it will open in the default web browser. Once the browser window opens, the user should wait until the map appears on the screen which indicates that all the data is loaded into the Application. This may take an additional ten seconds. The browser's zoom options can be used to adjust the size of the Application, similar to any website page.

## Home

The App is defaulted to open to the Home Tab. The home tab displays a satellite map which shows the location of the sampling sites. The site locations are represented by circles which are colored based on the watershed or reservoir that they are located in. One can navigate the map by panning the screen as well as zooming in and out of the map. One can hover over the circles to display the sampling site name. One can click on the circle to display more information about the site. This information includes "_________"


The sampling sites shown on the map are taken from the site tables in the Wachusett and Quabbin Water Quality Databases. If a sampling site is not shown the likely cause is that the site is not documented in one of the site tables in the database or that it is documented with the incorrect latitude and longitude coordinates. 


## Filter

The filter tab allows for the user to filter the water quality data that is presented in the rest of the App. This would be done if the user has a specific purpose of the session and knows that he/she will be using only a part of the data. In most of the other tabs in the App, there will be an option to use this filtered dataset instead of the full dataset. Choosing to use the filtered dataset will send only the . Any Location, Parameter, and Data selection widgets will now only display the categories that are 

The filter options includes three different temporal filters: a date range, a month selection, and a year selection. The date range selection is in the form of a calendar date range selection in which the user selects the desired starting and ending date of the dataset. The month and year selection allows the user to select the months or years of interest. All of these temporal filters are compounding and filter independently. For example, if a user selects the following: Date Range of 2010-01-01 to 2015-01-01, the Month of "May", and the year "2012"; this will result in data only for May of 2012. The user should be aware of situations in which there is less data than maybe expected, when the date range and year do not agree. For example, if a user selects the following Date Range of 2010-01-01 to 2015-01-01, and the year "2017"; this will result in no data selected.

The user can also filter the data by flags, storm sample, and meteorological conditions.

## Tributary

The Tributary tab allows the user to query, visualize, and analyze tributary sampling data. This tab has two sub-tabs called "Time-Series" and "Correlation". The "Time-Series" sub-tab allows the user to see temporal trends of water quality parameters via a plot, table, or summary statistics. The "Correlation" sub-tab allows the user to see correlations across parameters.

### Time-Series

The "Time-Series" sub-tab is further separated by watershed and shows temporal trends of the water quality parameters. The user is prompted to select the data of interest which is then displayed to the user as a plot, table, and summary statistics. 

#### Input Widgets 

The first widget the user selects is whether the user wants to use the full dataset or the filtered dataset which is determined by the filter tab. The second widget is the site location widget where the user selects the locations of interest. The locations are separated into location categories based on the categories in the database. The primary locations are always shown, while the sites in the other categories can be toggled to be displayed or hidden. Once a site is selected it appears as a red circle in the minimal, rather than a blue circle.

The Parameter Widget displays all the parameters that the data has based on the site selected. The parameter list updates each time a site location is added or removed to the list. The Date Range Widget is programmed to display the earliest and latest dates of the data corresponding to the selected site locations. The User can use the calendar view to select the desired date range of the data. 



### Correlation

The "Time-Series" sub-tab shows . This tab is further separated by watershed. 


## Reservoir - Bacteria
### Time-Series

The "Time-Series" sub-tab is identical in nature to the "Time-Series" sub-tab in the "Tributary" tab. This tab differs in the data it uses, yet the underlying code is the same. See Section ___ for more information.

### Correlation

The "Correlation" sub-tab is identical in nature to the "Time-Series" sub-tab in the "Tributary" tab. This tab differs in the data it uses, yet the underlying code is the same. See Section ___ for more information.

## Reservoir - Physiochemical
### Time-Series

The "Time-Series" sub-tab is identical in nature to the "Time-Series" sub-tab in the "Tributary" tab. This tab differs in the data it uses, yet the underlying code is the same. See Section ___ for more information.

### Correlation

The "Correlation" sub-tab is identical in nature to the "Time-Series" sub-tab in the "Tributary" tab. This tab differs in the data it uses, yet the underlying code is the same. See Section ___ for more information.

## Reservoir - Profile
### Time-Series
### Correlation
## MapPlot
## Forestry
## Hydro/Met
## Report

# DWSPI User Manual

# Shiny Developer Guide

## R
### Packages
## RStudio
## Shiny
### What is a Shiny App
### User Interface
### Server
### Reactivity
### Capabilities
### Limitations
## Github
## Database
## Remote Connection
## Tidy Data


# DWSPA Developement Manual

This text is meant for proficiency with Shiny. Please read and be familiar with the overall Shiny Developement Guide before attempting to understand this.

There are multiple script files that the Application comprises of. The App needs each of these files to be located in the correct location in order for the App to run. These files are organized into four main categories: Main, Functions, Modules, and Sources.


## App Layout

```{r diagram App, echo=FALSE}

pdf_digraph("diaApp.pdf", width = 200, "
      
      graph [rankdir = LR]
      
      # add node statements

      node [shape = oval, fixedsize = true, width = 1.8]
      App

      node[shape = rectangle, color = orange]
      H1 [label = 'Home']

      node[color = red]
      F1 [label = 'Filter']

      node[color = darkgreen]
      Tr1 [label = 'Tributary']

      
      node[color = blue]
      R1 [label = 'Reservoir']


      node[color = purple]
      M1 [label = 'MapPlot']


      node[color = deepskyblue]
      Hydro
      
      node[color = brown]
      Report
      
      # add edge statements
      edge [arrowhead = none, penwidth = 1.5]
      App -> {Report M1 Hydro M1 R1 Tr1 F1 H1}


")
  
```

### Home

### Filter

```{r diagram FilterTab, echo=FALSE}

pdf_digraph("FiltertTab.pdf", width = 200,  "

      graph [rankdir = LR]
      
      # add node statements

      node[shape = none]
      WQ1 [label = 'Water Quality']
      Hy2 [label = 'Hydrology']
      
      node [shape = rectangle, fixedsize = true, width = 1.8, color = red, penwidth = 1.5]
      F1 [label = 'Filter']
      Tr2 [label = 'Tributary']
      RB2 [label = 'Reservoir Bacteria']
      RC2 [label = 'Reservoir Chemical']
      RP2 [label = 'Reservoir Profile']
      Hydrology

      node[shape = oval]
      FW1 [label = 'Filter-WQ']
      FW2 [label = 'Filter-WQ']
      FW3 [label = 'Filter-WQ']
      FW4 [label = 'Filter-WQ']
      FH [label = 'Filter-Hydro']
      

      # add edge statements
      edge [arrowhead = none, penwidth = 1.5]
      F1 -> WQ1 -> Tr2 -> FW1
      WQ1 -> RB2 -> FW2
      WQ1 -> RC2 -> FW3
      WQ1 -> RP2 -> FW4
      F1 -> Hy2 -> Hydrology -> FH

")
  
```

### Tributary

```{r diagram TribTab, echo=FALSE}

pdf_digraph("TribTab.pdf", "

      graph [rankdir = LR]
      
      # add node statements
      
      node [shape = rectangle, fixedsize = true, width = 1.8, color = darkgreen, penwidth = 1.5]

      Tr1 [label = 'Tributary']
      Ti1 [label = 'Time-Series']
      Co1 [label = 'Correlation']
      Me1 [label = 'MetaData']
      Q1 [label = 'Quabbin']
      WR1 [label = 'Ware River']
      W1 [label = 'Wachusett']
      Q2 [label = 'Quabbin']
      WR2 [label = 'Ware River']
      W2 [label = 'Wachusett']
      QW3 [label = 'Quabbin and Ware']
      W3 [label = 'Wachusett']

      node[shape = oval]
      T1 [label = 'Time']
      T2 [label = 'Time']
      T3 [label = 'Time']
      C1 [label = 'Correlation']
      C2 [label = 'Correlation']
      C3 [label = 'Correlation']
      M1 [label = 'Metadata']
      M2 [label = 'Metadata']

      node[color = red]
      FW1 [label = 'Filter-WQ']

      node[shape = rectangle]
      Tr2 [label = 'Tributary']

      
      # add edge statements
      edge [arrowhead = none, penwidth = 1.5]

      Tr1 -> Ti1 -> {Q1 WR1 W1}
      Q1 -> T1
      WR1 -> T2
      W1 -> T3
      
      Tr1 -> Co1 -> {Q2 WR2 W2}
      Q2 -> C1
      WR2 -> C2
      W2 -> C3
      
      Tr1 -> Me1 -> {QW3 W3}
      QW3 -> M1
      W3 -> M2

      FW1 -> Tr2

      edge [dir = back, style = dotted]
      {T1 T2 T3 C1 C2 C3} -> FW1


")
  
```

### Reservoir

```{r diagram ResTab, echo=FALSE}

pdf_digraph("ResTab.pdf", "

       graph [rankdir = LR]
      
      # add node statements
      
      node[shape = none]
      RB1 [label = 'Bacteria']
      RC1 [label = 'Chemical']
      RP1 [label = 'Profile']
      RBio1 [label = 'Biological']

      node [shape = rectangle, fixedsize = true, width = 1.8, color = blue, penwidth = 1.5]
      R1 [label = 'Reservoir']
      Ti1 [label = 'Time-Series']
      Ti2 [label = 'Time-Series']
      Co1 [label = 'Correlation']
      Co2 [label = 'Correlation']
      Me1 [label = 'MetaData']
      Me2 [label = 'MetaData']
      LP [label = 'Line Plot']
      HM [label = 'Heat Map']
      Me3 [label = 'MetaData']
      Summary [label = 'Table and Summary ']
      Phytoplankton
      W1 [label = 'Wachusett']
      W2 [label = 'Wachusett']
      W3 [label = 'Wachusett']
      Q4 [label = 'Quabbin']
      W4 [label = 'Wachusett']
      Q5 [label = 'Quabbin']
      W5 [label = 'Wachusett']
      Q6 [label = 'Quabbin']
      W6 [label = 'Wachusett']
      Q7 [label = 'Quabbin']
      W7 [label = 'Wachusett']
      Q8 [label = 'Quabbin']
      W8 [label = 'Wachusett']
      Q9 [label = 'Quabbin']
      W9 [label = 'Wachusett']
      Q10 [label = 'Quabbin']
      W10 [label = 'Wachusett']
      W11 [label = 'Wachusett']

      node[shape = oval]
      T1 [label = 'Time']
      C1 [label = 'Correlation']
      M1 [label = 'Metadata']
      TD1 [label = 'Time-Depth']
      TD2 [label = 'Time-Depth']
      CD1 [label = 'Correlation-Depth']
      CD2 [label = 'Correlation-Depth']
      M2 [label = 'Metadata']
      M3 [label = 'Metadata']
      PH1 [label = 'Profile-Heatmap']
      PH2 [label = 'Profile-Heatmap']
      M4 [label = 'Metadata']
      M5 [label = 'Metadata']
      PS1 [label = 'Profile-Summary']
      PS2 [label = 'Profile-Summary']
      PL1 [label = 'Profile-Line']
      PL2 [label = 'Profile-Line']
      Phyto

      node[color = red]
      FW1 [label = 'Filter-WQ']
      FW2 [label = 'Filter-WQ']
      FW3 [label = 'Filter-WQ']
      FW4 [label = 'Filter-WQ']

      node[shape = rectangle]
      RB2 [label = 'Reservoir Bacteria']
      RC2 [label = 'Reservoir Chemical']
      RP2 [label = 'Reservoir Profile']
      RBio2 [label = 'Reservoir Biological']
      
      # add edge statements

      edge [arrowhead = none, penwidth = 1.5]

      # Bacteria
      R1 -> RB1 -> Ti1 -> W1 -> T1
      RB1 -> Co1 -> W2 -> C1
      RB1 -> Me1 -> W3 -> M1
      
      # Chemical
      R1 -> RC1 -> Ti2 -> Q4 -> TD1
      Ti2 -> W4 -> TD2
      RC1 -> Co2 -> Q5 -> CD1
      Co2 -> W5 -> CD2
      RC1 -> Me2 -> Q6 -> M2
      Me2 -> W6 -> M3
      
      # Profile
      R1 -> RP1 -> HM -> Q7 -> PH1
      HM -> W7 -> PH2
      RP1 -> LP -> Q8 -> PL1
      LP -> W8 -> PL2
      RP1 -> Summary -> Q9 -> PS1
      Summary -> W9 -> PS2
      RP1 -> Me3 -> Q10 -> M4
      Me3 -> W10 -> M5
      
      # Bio
      R1 -> RBio1 -> Phytoplankton -> W11 -> Phyto

      FW1 -> RB2
      FW2 -> RC2
      FW3 -> RP2
      FW4 -> RBio2

      edge [dir = back, style = dotted, arrowtail = vee]
      {T1 C1} -> FW1
      {TD1 TD2 CD1 CD2} -> FW2
      {PH1 PH2 PL1 PL2 PS1 PS2} -> FW3
      Phyto -> FW4

")
  
```

### MapPlot

```{r diagram MapplotTab, echo=FALSE}

pdf_digraph("MapPlotTab.pdf", "

      graph [rankdir = LR]
      
      # add node statements
      
      node[shape = none]
      Tr3 [label = 'Tributary']
      RB3 [label = 'Reservoir Bacteria']
      RC3 [label = 'Reservoir Chemical']

      node [shape = rectangle, fixedsize = true, width = 1.8, color = purple, penwidth = 1.5]
      M1 [label = 'MapPlot']
      Q1 [label = 'Quabbin'] 
      WR1 [label = 'Ware River']
      W1 [label = 'Wachusett']
      A1 [label = 'All Tribs']
      W2 [label = 'Wachusett']
      Q3 [label = 'Quabbin'] 
      W3 [label = 'Wachusett']
      
      node[shape = oval] 
      Mm1 [label = 'MapPlot']
      Mm2 [label = 'MapPlot']
      Mm3 [label = 'MapPlot']
      Mm4 [label = 'MapPlot']
      Mm5 [label = 'MapPlot']
      Mm6 [label = 'MapPlot']
      Mm7 [label = 'MapPlot']

      node[color = red]
      FW1 [label = 'Filter-WQ']
      FW2 [label = 'Filter-WQ']
      FW3 [label = 'Filter-WQ']
      
      node[shape = rectangle]
      Tr2 [label = 'Tributary']
      RB2 [label = 'Reservoir Bacteria']
      RC2 [label = 'Reservoir Chemical']
      
      # add edge statements

      edge [arrowhead = none, penwidth = 1.5]
      M1 -> Tr3 -> Q1 -> Mm1
      Tr3 -> WR1 -> Mm2
      Tr3 -> W1 -> Mm3
      Tr3 -> A1 -> Mm4

      M1 -> RB3 -> W2 -> Mm5
      
      M1 -> RC3 -> Q3 -> Mm6
      RC3 -> W3 -> Mm7

      FW1 -> Tr2
      FW2 -> RB2
      FW3 -> RC2

      edge [dir = back, style = dotted, arrowtail = vee]
      {Mm1 Mm2 Mm3 Mm4} -> FW1
      {Mm5} -> FW2
      {Mm6 Mm7} -> FW3

")
  
```

### Hydro

### Report


## Main Script

```{r diagram main, echo=FALSE}

pdf_digraph("diaModuls.pdf", "
      
      graph [rankdir = LR, ranksep = 1.5]
      
      # add node statements
      node [shape = octagon, fixedsize = true, width = 2, penwidth = 1.5]
      GetSeasons; CircleSizeLegends; PhytoPlot

      node [shape = oval]
      
      # add edge statements
      rank = same; Home; Filter
      
      edge [arrowhead = none, penwidth = 1.5]
      App -> {Home Filter Time TimeDepth Correlation CorrelationDepth ProfileHeatmap ProfileLine ProfileSummary Phyto MapPlot Report}
      
      Time-> {SiteSelection ParamSelect DateSelect SiteMap PlotTime Summary}
      Correlation -> {SiteSelection ParamSelect DateSelect SiteMap PlotCorr Summary}
      TimeDepth -> {StationLevelSelection ParamSelect DateSelect SiteMap PlotTimeDepth SummaryDepth}
      CorrelationDepth -> {StationLevelSelection ParamSelect DateSelect SiteMap PlotCorrDepth SummaryDepth}
      
      {SiteSelection StationLevelSelection} -> CheckboxSelectAll
      ParamSelect -> SelectInputSelectAll

      Filter -> {CheckboxSelectAll SelectInputSelectAll}

      {Summary SummaryDepth} -> GetSeasons
      MapPlot -> CircleSizeLegends
      Phyto -> PhytoPlot


")
  
```

### App.R
### LoadMSAccess.R
### LaunchApp.R

## Modules (General)

### Module overview
### Module Syntax
### Module Naming
### Passing Reactives in and out of Modules

It can be tricky when dealing with passing reactive expressions into and out of modules. Reactive expressions must be passed in the unresolved reactive expression form ("input1") rather than the resolved reactive expression form ("input1()"). Since reactive expressions are a type of function in R, one is essentially passing the unresolved function into the module instead of the resolved value that the function produces. If one incorrectly passes a resolved reactive expression value through modules, the reactivity will not work correctly.

Passing a reactive expression out of a module is useful when one wants to access a value in an upper level module that is created inside an inner module. An example of when this is used in the App is when the selected value from Check Box Select All UI Widget (checkBoxSelectAll.R). 

It is best to understand the underlying principle of modules when dealing with this task. 

## Primary Modules

### Home.R
### Filter-WQ.R


### Time.R



The parameter widget display all the parameters that the data has based on the site selected. The parameter list updates each time a site location is added or removed to the list. The parameter list was built in a way to remember which parameter was selected, so when the site list is changed, the parameter list updates but the previously selected parameter will be reselected automatically. If the previously selected parameter is not in the new updated list, than no parameter is selected and the user will be prompted to select a parameter. If a parameter was selected and than the user deselects all of the sites, the code would want to set the parameter list to an empty list, and therefore the parameter could not be saved. A work around for this was to tell the program that if no site is selected than make the parameter list consist of just the previously selected parameter and have this parameter be selected.


```{r diagram time, echo=FALSE}

pdf_digraph("Time.pdf", width = 350 , "
      
      graph [rankdir = LR]
      
      # add node statements
      
      node [shape = octagon, fixedsize = true, width = 2, penwidth = 1.5]
      GetSeasons

      node [shape = oval]
      
      # add edge statements
      
      edge [dir = both, arrowtail = vee, arrowhead = vee, penwidth = 1.5] 
      Time -> {SiteSelection ParamSelect DateSelect}
      SiteSelection -> CheckboxSelectAll
      ParamSelect -> SelectInputSelectAll

      edge [dir = front]
      Time-> {SiteMap PlotTime StatTime}

      edge [arrowhead = none]
      StatTime -> GetSeasons
")
  
```

### Correlation.R

```{r diagram Corr, echo=FALSE}

pdf_digraph("diacorr.pdf",width = 200, "
      
      graph [rankdir = LR]
      
      # add node statements
      
      node [shape = octagon, fixedsize = true, width = 2, penwidth = 1.5]
      GetSeasons

      node [shape = oval]

      # add edge statements
      
      edge [dir = both, arrowtail = vee, arrowhead = vee, penwidth = 1.5] 
      Correlation -> {SiteSelection PS1 PS2 DateSelect}
      SiteSelection -> CheckboxSelectAll
      {PS1 [label = 'ParamSelect']} -> {SI1 [label = 'SelectInputSelectAll']}
      {PS2 [label = 'ParamSelect']} -> {SI2 [label = 'SelectInputSelectAll']}
      
      edge [dir = front]
      Correlation -> {SiteMap PlotCorr StatCorr}
      
      edge [arrowhead = none]
      StatCorr -> GetSeasons

")
  
```

### Time-Depth.R

```{r diagram time Depth, echo=FALSE}

pdf_digraph("diatimedep.pdf", width = 250, "
      
      graph [rankdir = LR]
      
      # add node statements
      
      node [shape = octagon, fixedsize = true, width = 2, penwidth = 1.5]
      GetSeasons
      
      node [shape = oval]

      # add edge statements
      
      edge [dir = both, arrowtail = vee, arrowhead = vee, penwidth = 1.5] 
      TimeDepth -> {SiteSelection ParamSelect DateSelect}
      SiteSelection -> CheckboxSelectAll
      ParamSelect -> SelectInputSelectAll
      
      edge [dir = front]
      TimeDepth -> {SiteMap PlotTimeDepth StatTimeDepth}
      
      edge [arrowhead = none]
      StatTimeDepth -> GetSeasons

")
  
```

### Corrlation-Depth.R


```{r diagram corr Depth, echo=FALSE}

pdf_digraph("diacorrdep1.pdf", width = 300, "
      
      graph [rankdir = LR]
      
      # add node statements
      
      node [shape = octagon, fixedsize = true, width = 2, penwidth = 1.5]
      GetSeasons
      
      node [shape = oval]

      # add edge statements
      
      edge [dir = both, arrowtail = vee, arrowhead = vee, penwidth = 1.5] 
      CorrelationDepth -> {SiteSelection PS1 PS2 DateSelect}
      SiteSelection -> CheckboxSelectAll
      {PS1 [label = 'ParamSelect']} -> {SI1 [label = 'SelectInputSelectAll']}
      {PS2 [label = 'ParamSelect']} -> {SI2 [label = 'SelectInputSelectAll']}
      
      edge [dir = front]
      CorrelationDepth -> {SiteMap PlotCorrDepth StatCorr}
      
      edge [arrowhead = none]
      StatCorr -> GetSeasons

")
  
```


### Profile-Line
### Profile-Heatmap
### Profile-Summary
### Phyto
### Mapplot (module)

The MapPlot module is  incorporated in the App in under the MapPlot tab.


When the Base Leaflet Map contains the Map Tiles and the Circle Markers for the Site Locations. It is not neccesary to 
to specify the starting min/max Lat/Long coordinates becuase the location of the markers tell it where to start.
Leaflet and RenderUI do not work well together. If this is needed, an action button is a solution but from my experience still causes some problems

### Hydro.R
### Forestry.R
### Report.R

## Secondary Modules - Input



 Secondary Input modules serve the purpose of creating more complex input widgets that are used in multiple places throughout the App. Just like all modules, these are separated into their own modules to create more efficient writing of code. 
 
### CheckboxSelectAll.R
### SelectInputSelectAll.R
### SiteCheckbox.R
### StationLevelCheckbox.R
### Date Select.R
### ParameterCheckbox.R
### ParameterSelect.R
### Saving Inputs (Widget Memory)

Related Scripts: 

The functioning of these aforementioned input widgets, is actually much more complex than previously mentioned due to the want for the App to remember an input widget's previously selected value when an input is updated. For example, when a user changes the selected site(s) on the Site Input Widgets, the Parameter Input Widget choices update to a new list of corresponding parameters contained within the new Site's data. The updated Parameter Input Widget will not automatically select the previously selected choice. This will not be problematic, if the user follows the prefered order of selection: 

1. Select the "full" or "filtered" data options. If the "filtered" data option is selected than the user should select any filters on the Filter Tab. 
2. Select desired site(s).
3. Select Parameter and Date Range. The order of selection between these two do not matter.

Figure 2 shows a simplistic view of how these widgets react with eachother. 

To unconstrain the user from this specific work flow, the Application is programmed to have more or less a memory, of these Input Widget's selected values. A few questions arise that the developer must ask himself/herself when programming the App to memorize the previously selected values and automatically select them:

1. If one does program an Input Widget to have an initial selected value be the previously selected value, what happens when the App is first started and there is no previously selected value? How will this value be defined in the Apps beginning state?

The seemingly best resolution to the first question lies in the set of input updater functions (e.g. *updateCheckboxGroupInput, updateSelectInput, updateDateRangeInput*) that Shiny has created for this type of problem. The input updater funtions send a message to change the settings of the output object (@updateCheckBoxGroupInput). The input updater functions should be contained within an observer function, whether be observe() or observeEvent(). The updater function essentially allows to seperate the initial rendering of the Input Widget with the updating renderings of the Input Widget based on the changing of inputs and reactive expressions that the Input Widget depends on. Code segment 1 shows a simplified portion of the ParamSelect.R script for the purpose of illustraing the seperate selectInput() and updateSelectInput() functions for the same Input Object. In this code, the *selectInput* function's "selected" argument is set undefined and thus defaulted to NULL for a multiple select selectInput Object. The *updateSelectInput* function's "selected" argument is defined as **save.selected** which is the previously selected value. The"save selected" value will be discusses at depth in the next section  "___". . Please note that the code that defines the param.choices reactive expression is not shown in this segment for "______" reasons but essentially is all the parameter types within the active dataframe filtered for the selected sites.

```{r Code 1, eval=FALSE}

  # Parameter Selection UI
  output$type.ui <- renderUI({
    ns <- session$ns # see General Note 1
    selectInput(ns("type"), "Parameter:", choices=c(param.choices()), multiple = TRUE)
  })
  
  
  # Update Parameter Selection for new choices
  observe({
      updateSelectInput(session, inputId = "type", label = "Parameter:", 
                        choices=c(param.choices()),
                        selected = save.selected)
  })
  
```

2. How do you set the selected value of an Input Widget to it's own previously selected value, when in this process the App destroys the previous Input Widget before it builds the updated Input Widget?

To answer the second question, one may first attept to assign the selected value of an Input Widget to it's own reactive expression which we will call "Saved_Value_Reactive". This however does not work, due to "Saved_Value_Reactive" being reactively dependent on the value of the Input Widget. Once the Input Widget is deemed "___", than all of its reactive dependencies are also deemed "___" . Due to the order that Shiny executes reactive objects, the . Even if Shiny did not have this property , this would theortically create a reactive loop, due the the Input Widget depending on the value of the "Saved_Value_Reactive" to know what value to have inially selected and the "Saved_Value_Reactive" depending on the selected value of the Input Widget. To solve this problem, there actually needs to be a forced break in reactivity with the *isolate* function. The **save.selected** variable is set to the "current" value of the Input Widget before the input updater function is executed, thus saving what will become the "previous" value once the input updater function is executed in the next code chunk. Becuase **save.selected** is surrounded by the *isolate* function, it will not try to update itself during the updating of the Input Widget. Code Segment 2 shows how the *isolate* function is used to assign an Input Widget value as a means of saving a previous value.

```{r Code 2, eval=FALSE}
  
  # Parameter Selection UI
  output$type.ui <- renderUI({
    ns <- session$ns # see General Note 1
    selectInput(ns("type"), "Parameter:", choices=c(param.choices()), multiple = TRUE)
  })


  # Update Parameter Selection for new choices and TO AUTOMATICALLY SELECT THE PREVIOUSLY SELECTED INPUT
  observe({
    
    # sAVE THE INPUT WHEN CHOICES CHANGE, BEFORE INPUT IS UPDATED. ISOLATE DISRUPTS REACTIVITY
    isolate({
        save.selected <- input$type
    })

      updateSelectInput(session, inputId = "type", label = "Parameter:", 
                        choices=c(param.choices()),
                        selected = save.selected)
  })
  
```

3. What should happen if the previously selected value does not exist in the updated Input Widget's choices?

If an Input Widget is told to start with an inital selection that is not within the choices that the widget has, the widget will start with nothing selected. We will think about the situation when a user is viewing data for the Turbidity parameter and changes then selects a site that does not contain any Turbidity data. Keep in mind that when the user selected the site, he/she may not have been aware that the site does not contain Turbidity data. Due to the Turbidity parameter not being one of the updated parameter choices, The Input Widget will have nothing inially selected (it be blank). This naturally behavior of Shiny is seems to be desirable for this application, and yet no additional code was written in response to this question, yet the bahavior is good to keep in mind. If the user is scanning through various sites with set parameters and/or date ranges, he/she would like to be notified when a site by seeing blank data, rather than seeing other data than is expected to see and addicentally mistaking this data for the previous parameter and date ranges. Generally, notifying the user when inputs have changed that are not directly caused by the user's click is preferable than to not notifying the user and risking that he/she is unaware of the change. This is behavior is likely the cause anytime, an input object with this type of "memory" becomes blank during the session.



4. What if the user deselects all sites?

Based on the previously written code (code segment 2), an issue arises if the user deselects all sites (all sites are unselected) which would create an Input Widget with zero parameter choices (an empty list). This does not seem troublesome at first thought, but when the Input Widget is generated with an empty list, it therefore loses it ability to store the previously selected value. Let's take the situation where a user was curious about Turbidity data and has site "A" at has the proper Input Widgets selected to view this data. If the user now wants to select site "B", the user has two approaches of doing so:

* Approach 1: The user deselects Site "A" and then selects Site "B"
* Approach 2: The user selects Site "B" and then deselects Site "A"

Given approach 1 is taken, Once Site "A" is selected than the Input Widget is generated with an empty choice list. Becuase the previously stored value of Turbidity (**save.selected**) is not contained within this empty site list, the selected value will be set to nothing (blank). When the user then selecsts Site "B" then the input updater function updates the Input Widget and it thinks that the previously selected value is nothing (blank). To alleviate this unpleasantness, an if statement is added for the two discrete situations where the site list is empty (NULL) and isn't empty (NULL).

```{r Code 3, eval=FALSE}

  # Parameter Selection UI
  
  output$type.ui <- renderUI({
    ns <- session$ns # see General Note 1
    selectInput(ns("type"), "Parameter:", choices=c(param.choices()), multiple = TRUE)
  })
  
  
  
  # To fill back in previously selected
  
  observe({
    
    # save the Parameter Type input for when the site selection changes. 
    # Isolate so does not cause reactivity
    isolate({
        save.selected <- input$type
    })
    
    # If Site list is changed but not empty then generate a Select Input with the... 
    # parameters for that site and autoselect previous selected parameter 
    if(!is.null(site())){
      
      updateSelectInput(session, inputId = "type", label = "Parameter:", 
                        choices=c(param.choices()),
                        selected = save.selected)
    
      # If site list is empty than make a parameter list of just the previously listed item to save it.
    } else {
      updateSelectInput(session, inputId = "type", label = "Parameter:", 
                        choices= save.selected,
                        selected = save.selected)
    }
    
  })
  
```



It is common 


This difference in simplicity occurs due to the fact that the Selection Widgets choices only depends on the full or filtered data the complication of Parameter Widget and Date Range Widget arises becuase the choices that the user is allowed to select is limited to that 

The Parameter Input Widget was built in a way to remember which parameter was selected, so when the site list is changed, the parameter list updates but the previously selected parameter will be reselected automatically. If the previously selected parameter is not in the new updated Parameter Widget choices, than no parameter is selected and the user will be prompted to select a parameter. If a parameter was selected and than the user deselects all of the sites, the program will create a parameter list just containing the previously selected parameter for saving purposes, even though there should actually be no parameters contained within the empty site list.


The Date Range Widget acts similar to the Parameter Widget. The Date Range Widget is also updated each time a location is added or removed from the list. The Date Range was built to remember which Date Range was previously selected and when the site list is changed by the user, the Date Range updates but the previously selected Dates will be selected automatically. If the previously date range is not within the limits of the new updated Date Rnage Widget choice range, than no date range is selected and the user will be promted to select a date. If a date range was 





* need to make Site Selection reactive to the filter data



## Secondary Modules - Output

### Plot-Time.R
### Plot-Time-Depth.R
### Plot-Correlation.R
### Plot-Correlation-Depth.R
### Plot-Profheat.R
### Plot-Profline.R
### Summary.R
### Summary-Depth.R
### Summary-Profile.R

## Secondary Modules - UI  -  Get rid of this and make into output

## Functions

### CircleSizeLegends.R
### GetSeasons.R
### Phytoplots.R

## General Notes

### 1. Conditional Panel in Module

Conditional panels and shiny modules don't work well togethr due to the ns() wrapper requrement. Javascript must be used in the conditions of the conditional panel.

## Future Work


# DWSPI Developer Manual


# Appendix A - R package Resources
## R
## RStudio
## Shiny
## RMarkdown
## Leaflet
## Other Packages
# Appendix B - Database Tables
## Tributary Data
## Reservoir Data
## Site Location Data
## Parameter Data
# Appendix C -Reports
## Annual Water Quality Report
## Monthly Water Quality Report
## Custom Report
# Appendix D - Application Scripts

# References
